Array#each_cons(cnt)はselfからcnt個ずつ要素を取り出しブロックに渡します。ブロック引数には配列で渡されます。
取り出す要素は、[要素1, 要素2, 要素3], [要素2, 要素3, 要素4] ...と1つづ前に進みます。

似たメソッドにArray#each_slick(cnt)があります。
以下が、それぞれの実行結果です。

(1..10).each_cons(3) {|arr| p arr }

# <実行結果>
# [1, 2, 3]
# [2, 3, 4]
# [3, 4, 5]
# [4, 5, 6]
# [5, 6, 7]
# [6, 7, 8]
# [7, 8, 9]
# [8, 9, 10]
(1..10).each_slice(3) {|arr| p arr }

# <実行結果>
# [1, 2, 3]
# [4, 5, 6]
# [7, 8, 9]
# [10]



Rubyではメソッド内で定数を定義することができません。
複数回メソッドを呼び出した場合に、定数が不定となるため定義できません。
宣言された場合は、SyntaxErrorが発生します。


Hash#delete(:key)はレシーバーからkeyの項目を削除します。
このメソッドは破壊的メソッドです。


次の表が、問題文と選択肢のメソッドの一覧と意味です。

メソッド名	意味
find_all, select	各要素に対してブロックを評価した結果が、真である要素の配列を作成し返します
find, detect	要素に対してブロックを評価した結果が、最初に真になった要素を返します
collect, map	各要素に対してブロックを評価した結果を配列に格納し返します
delete_if, reject! ブロックを評価した値が真になった最初の要素を返します




a+
recode 1
recode 2
recode 3
RECODE 1
RECODE 2
RECODE 3
a+はファイルを読み込みモード + 追記書き込みモードで開きます。
ファイルの読み込みは、ファイルの先頭から行いますが、書き込みは、ファイルの末尾に行います。
f.rewindでファイルポインタをファイルの先頭に移動したとしても、ファイルの末尾に書き込まれます。

w+
空ファイルになります。

w+は新規作成・読み込み + 書き込みモードで開きます。
既にファイルが存在する場合は、空になります。

r+
RECODE 1
RECODE 2
RECODE 3
r+は読み込み + 書き込みモードで開きます。


-----
p [1,2,3,4].map do |e| e * e end

do ... endと{ ... }を比べた場合、{ ... }の方が結合度が強いです。

問題の式の場合、do ... endの結合度が弱いため、p([1, 2, 3, 4].map)が評価されます。
問題のように式の内容を直接使用する際は、{ ... }を使用します。


-----
strip	文字列の先頭と末尾の空白文字(\t\r\n\f\v)を取り除きます。
strip!	文字列の先頭と末尾の空白文字(\t\r\n\f\v)を破壊的に取り除きます。
chomp	末尾から改行コードを取り除きます。
chop	末尾の文字を取り除きます。ただし、文字列の末尾が"\r\n"であれば、2文字とも取り除きます。


-----
to_s 文字列
to_i 整数
to_f 浮動小数点
to_r 有理数
to_c 複素数
to_sym シンボル
